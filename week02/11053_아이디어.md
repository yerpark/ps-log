
# 📈 Patience Sort 기반 Longest Increasing Subsequence (LIS) 알고리즘 - 3단계 정리

---

## ✅ 단계별 개요

| 단계 | 구조 | 목적 | 구현 난이도 |
|------|------|------|-------------|
| 1단계 | 전체 카드(pile) 저장 + prev 추적 | 수열 재구성 + 이해 중심 | ⭐⭐⭐⭐ |
| 2단계 | 인덱스만 추적 (`T[]`, `R[]`) | 메모리 압축 + 수열 복원 가능 | ⭐⭐⭐ |
| 3단계 | 값만 추적 (`dp[]`) | 길이만 필요할 때 최적화 | ⭐ |

---

## 🧩 Step 1: 풀 구조 (Card 객체 + pile 연결)

### ✅ 설명
- 모든 카드를 pile에 객체 형태로 저장
- 각 카드가 `.prev` 포인터로 왼쪽 pile의 top을 가리킴
- 가장 오른쪽 pile에서 `.prev` 따라가면 실제 LIS 수열 복원 가능

### ✅ 특징
- 구조 완벽하게 보존
- 수열 추적 확실
- 가장 직관적 (비주얼 이해에 좋음)

---

## 🧠 Step 2: 중간 압축 구조 (T[], R[] 이용)

### ✅ 설명
- `T[i]`: 길이 `i+1`짜리 증가 수열의 끝 값의 **인덱스**
- `R[i]`: 해당 인덱스의 **이전 원소 인덱스** (수열 추적용)
- 이진 탐색으로 적절한 위치 찾아 `T` 갱신

### ✅ 특징
- 메모리 구조 압축 (객체 사용 X)
- 경로 재구성 가능 (`R[]`)
- 알고리즘은 동일, 구현만 최적화

### ✅ Java 코드 예시
```java
T[len] = i;
R[T[len]] = T[len-1]; // 이전 원소 연결



파일 더미 구현 -> 어떻게 압축? 
✅ 각 pile의 top 값만 관리하면 충분 => 1차원 배열로 압축 

